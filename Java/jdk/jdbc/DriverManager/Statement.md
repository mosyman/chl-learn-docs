


你想让我解释 `Statement` 接口的核心注释和 `executeQuery()`、`executeUpdate()`、`close()` 这三个核心方法，我会从接口定位、方法功能、使用规则和关键注意事项等方面帮你讲清楚。

### 一、整体功能总结
`Statement` 是 JDBC 中用于**执行静态 SQL 语句并返回执行结果**的核心接口，它由 `Connection.createStatement()` 创建，是执行无参数 SQL 的基础工具；同时它定义了执行查询、更新类 SQL 的专属方法，还有严格的资源管理规则。

### 二、接口级注释解析（最核心的规则）
```java
/**
 * <P>The object used for executing a static SQL statement
 * and returning the results it produces.
 * <P>
 * By default, only one {@code ResultSet} object per {@code Statement}
 * object can be open at the same time. Therefore, if the reading of one
 * {@code ResultSet} object is interleaved
 * with the reading of another, each must have been generated by
 * different {@code Statement} objects. All execution methods in the
 * {@code Statement} interface implicitly close a current
 * {@code ResultSet} object of the statement if an open one exists.
 *
 * @see Connection#createStatement
 * @see ResultSet
 * @since 1.1
 */
public interface Statement extends Wrapper, AutoCloseable {
```
这部分是 `Statement` 接口的核心规则，必须重点掌握：
1. **核心定位**：专门执行「静态 SQL 语句」（无参数的 SQL），并返回执行结果。
2. **ResultSet 限制（最关键）**：
    - 一个 `Statement` 对象**同一时间只能打开一个 ResultSet**（结果集）；
    - 如果需要同时操作多个结果集（比如交替读取两个查询结果），必须为每个结果集创建独立的 `Statement` 对象；
    - 调用 `Statement` 的任意执行方法（如 `executeQuery()`、`executeUpdate()`）时，会**自动关闭该 Statement 上已打开的 ResultSet**（避免资源冲突）。
3. **继承关系**：
    - `Wrapper`：支持向下转型获取数据库厂商的底层实现（比如 MySQL 的 `MySQLStatement`）；
    - `AutoCloseable`：支持 try-with-resources 语法，自动关闭 Statement（推荐使用，避免资源泄漏）。

### 三、核心方法逐一看
#### 1. `executeQuery(String sql)`：执行查询类 SQL
```java
/**
 * Executes the given SQL statement, which returns a single
 * {@code ResultSet} object.
 *<p>
 * <strong>Note:</strong>This method cannot be called on a
 * {@code PreparedStatement} or {@code CallableStatement}.
 * @param sql an SQL statement to be sent to the database, typically a
 *        static SQL {@code SELECT} statement
 * @return a {@code ResultSet} object that contains the data produced
 *         by the given query; never {@code null}
 * @throws SQLException if a database access error occurs,
 * this method is called on a closed {@code Statement}, the given
 *            SQL statement produces anything other than a single
 *            {@code ResultSet} object, the method is called on a
 * {@code PreparedStatement} or {@code CallableStatement}
 * @throws SQLTimeoutException when the driver has determined that the
 * timeout value that was specified by the {@code setQueryTimeout}
 * method has been exceeded and has at least attempted to cancel
 * the currently running {@code Statement}
 */
ResultSet executeQuery(String sql) throws SQLException;
```
##### 核心解读
- **用途**：专门执行**查询类 SQL**（主要是 `SELECT` 语句），返回包含查询结果的 `ResultSet`。
- **关键特性**：
    - 返回值**永远不为 null**（即使查询结果为空，也是空的 ResultSet，而非 null）；
    - 只能执行「返回且仅返回一个 ResultSet」的 SQL，如果 SQL 执行后产生多个结果（比如存储过程），会抛出异常；
    - **禁止在 `PreparedStatement`/`CallableStatement` 上调用**（这两个子类有自己的 `executeQuery()` 重载方法，无需传 SQL）。
- **异常场景**：
    - 数据库访问错误、调用已关闭的 Statement；
    - SQL 不是单结果集查询（比如执行了 `INSERT` 再 `SELECT`）；
    - 超时（`setQueryTimeout()` 设置的超时时间到了，驱动会尝试取消执行）。
- **使用示例**：
  ```java
  try (Connection conn = DriverManager.getConnection(url, user, pwd);
       Statement stmt = conn.createStatement()) {
      // 执行查询
      ResultSet rs = stmt.executeQuery("SELECT id, name FROM user WHERE age < 30");
      // 遍历结果集
      while (rs.next()) {
          System.out.println("ID: " + rs.getInt("id") + ", 姓名: " + rs.getString("name"));
      }
  } catch (SQLException e) {
      e.printStackTrace();
  }
  ```

#### 2. `executeUpdate(String sql)`：执行更新类 SQL
```java
/**
 * Executes the given SQL statement, which may be an {@code INSERT},
 * {@code UPDATE}, or {@code DELETE} statement or an
 * SQL statement that returns nothing, such as an SQL DDL statement.
 *<p>
 * <strong>Note:</strong>This method cannot be called on a
 * {@code PreparedStatement} or {@code CallableStatement}.
 * @param sql an SQL Data Manipulation Language (DML) statement, such as {@code INSERT}, {@code UPDATE} or
 * {@code DELETE}; or an SQL statement that returns nothing,
 * such as a DDL statement.
 *
 * @return either (1) the row count for SQL Data Manipulation Language (DML) statements
 *         or (2) 0 for SQL statements that return nothing
 *
 * @throws SQLException if a database access error occurs,
 * this method is called on a closed {@code Statement}, the given
 * SQL statement produces a {@code ResultSet} object, the method is called on a
 * {@code PreparedStatement} or {@code CallableStatement}
 * @throws SQLTimeoutException when the driver has determined that the
 * timeout value that was specified by the {@code setQueryTimeout}
 * method has been exceeded and has at least attempted to cancel
 * the currently running {@code Statement}
 */
int executeUpdate(String sql) throws SQLException;
```
##### 核心解读
- **用途**：执行**更新类/无返回结果的 SQL**，包括：
    - DML 语句：`INSERT`（插入）、`UPDATE`（更新）、`DELETE`（删除）；
    - DDL 语句：`CREATE TABLE`（建表）、`DROP TABLE`（删表）、`ALTER TABLE`（改表）等（无返回结果）。
- **返回值规则**：
    - 执行 DML 语句：返回**受影响的行数**（比如 `DELETE` 删了 5 行，返回 5）；
    - 执行 DDL 语句：返回 0（因为无行数据受影响）。
- **禁止场景**：不能执行返回 `ResultSet` 的 SQL（比如 `SELECT`），否则抛出异常；同样禁止在 `PreparedStatement`/`CallableStatement` 上调用。
- **使用示例**：
  ```java
  try (Connection conn = DriverManager.getConnection(url, user, pwd);
       Statement stmt = conn.createStatement()) {
      // 执行更新（DELETE），返回受影响行数
      int affectedRows = stmt.executeUpdate("DELETE FROM user WHERE age > 50");
      System.out.println("删除了 " + affectedRows + " 行数据");

      // 执行DDL（CREATE TABLE），返回0
      int ddlResult = stmt.executeUpdate("CREATE TABLE log (id INT, content VARCHAR(255))");
      System.out.println("建表结果：" + ddlResult); // 输出 0
  } catch (SQLException e) {
      e.printStackTrace();
  }
  ```

#### 3. `close()`：释放资源
```java
/**
 * Releases this {@code Statement} object's database
 * and JDBC resources immediately instead of waiting for
 * this to happen when it is automatically closed.
 * It is generally good practice to release resources as soon as
 * you are finished with them to avoid tying up database
 * resources.
 * <P>
 * Calling the method {@code close} on a {@code Statement}
 * object that is already closed has no effect.
 * <P>
 * <B>Note:</B>When a {@code Statement} object is
 * closed, its current {@code ResultSet} object, if one exists, is
 * also closed.
 *
 * @throws SQLException if a database access error occurs
 */
void close() throws SQLException;
```
##### 核心解读
- **用途**：立即释放 `Statement` 占用的数据库/JDBC 资源（而非等待 GC 自动回收），避免数据库连接/游标等资源被长期占用。
- **关键规则**：
    - 调用已关闭的 `Statement` 的 `close()` 方法，**无任何效果**（不会抛异常）；
    - 关闭 `Statement` 时，会**自动关闭它关联的 ResultSet**（即使 ResultSet 还没遍历完）。
- **最佳实践**：
    - 优先使用 try-with-resources 语法（自动调用 `close()`），无需手动写 `close()`；
    - 如果手动管理资源，务必在 finally 块中调用 `close()`，确保资源释放。

### 总结
1. `Statement` 用于执行静态无参数 SQL，**同一时间只能关联一个 ResultSet**，执行新 SQL 会自动关闭旧 ResultSet；
2. `executeQuery()` 专用于 `SELECT` 等查询，返回非 null 的 ResultSet，`executeUpdate()` 专用于 DML/DDL，返回受影响行数或 0；
3. 资源管理是核心：关闭 Statement 会自动关闭其关联的 ResultSet，推荐用 try-with-resources 自动释放资源，避免泄漏。










