
![变量声明形式决策](img/变量声明形式决策.png)




这几页内容是 Go 语言编码规范中关于**变量声明一致性**的最佳实践，我帮你整理成清晰的规则和实践指南，方便你直接应用到代码中。

---

## 一、核心原则
Go 语言变量声明的核心目标是：**保持项目范围内的一致性**，并遵循“就近原则”，让变量的作用域最小化。

Go 变量分为两类：
- **包级变量（Package Variable）**：在包级别声明，对整个包可见（若导出则对外部包也可见）。
- **局部变量（Local Variable）**：在函数或方法内声明，仅在函数/方法体内可见。

---

## 二、包级变量的声明规范

### 1. 声明并同时显式初始化
- **推荐格式**：`var variableName = InitExpression`
- Go 编译器会自动根据右侧表达式的类型推断左侧变量的类型。
- 如果不接受默认类型，推荐显式指定类型，以保持声明形式的统一：
  ```go
  // 推荐：显式指定类型，统一风格
  var (
      a = int32(17)
      f = float32(3.14)
  )

  // 不推荐：混合风格，可读性差
  var (
      a = 17
      f float32 = 3.14
  )
  ```

### 2. 声明但延迟初始化
- 使用最基本的 `var` 声明形式，变量会被初始化为“零值”。
  ```go
  var a int32
  var f float64
  ```
- 对于自定义类型，保证其零值可用是非常必要的。

### 3. 声明聚类与就近原则
- **声明聚类**：将同一类的包级变量放在一个 `var` 块中。
  ```go
  // $GOROOT/src/net/http/server.go
  var (
      bufioReaderPool sync.Pool
      bufioWriter2kPool sync.Pool
      bufioWriter4kPool sync.Pool
  )
  ```
- **就近原则**：如果一个包级变量仅在某个函数中使用，应将其声明在该函数附近；如果在包内多处使用，则放在源文件头部。

---

## 三、局部变量的声明规范

### 1. 延迟初始化的局部变量
- 采用带有 `var` 关键字的声明形式。
  ```go
  func (r *byteReplacer) Replace(s string) string {
      var buf []byte // 延迟分配
      // ...
  }

  func Foo() {
      var err error // 常见于 defer 闭包中
      defer func() {
          if err != nil {
              // ...
          }
      }()
      err = Bar()
      // ...
  }
  ```

### 2. 声明且显式初始化的局部变量
- **推荐使用短变量声明形式 `:=`**，这是局部变量最常用的声明形式，遍布 Go 标准库。
  ```go
  a := 17
  f := 3.14
  s := "hello, gopher!"

  // 不接受默认类型时，进行显式转型
  a := int32(17)
  f := float32(3.14)
  s := []byte("hello, gopher!")
  ```

### 3. 分支控制时应用短变量声明
- 在 `if`、`for` 等分支控制语句中，使用短变量声明将变量与语句融合，体现“就近原则”，最小化变量作用域。
  ```go
  // $GOROOT/src/net/net.go
  func (v *Buffers) WriteTo(w io.Writer) (n int64, err error) {
      if wv, ok := w.(buffersWriter); ok {
          return wv.writeBuffers(v)
      }
      for _, b := range *v {
          nb, err := w.Write(b)
          n += int64(nb)
          if err != nil {
              v.consume(n)
              return n, err
          }
      }
      v.consume(n)
      return n, nil
  }
  ```

### 4. 复杂场景下的 `var` 块
- 当函数内需要声明大量局部变量时，可以使用 `var` 块来聚合声明，提升可读性。
  ```go
  func (r *Resolver) resolveAddrList(...) (addrList, error) {
      var (
          tcp   *TCPAddr
          udp   *UDPAddr
          ip    *IPAddr
          wildcard bool
      )
      // ...
  }
  ```

---

## 四、总结与实践建议

| 变量类型 | 场景                     | 推荐声明形式                          |
| :------- | :----------------------- | :------------------------------------ |
| **包级** | 显式初始化               | `var a = int32(17)` 或 `var` 块       |
| **包级** | 延迟初始化（零值）       | `var a int32`                         |
| **包级** | 聚类/就近                | 同类变量放一个 `var` 块，就近使用处声明 |
| **局部** | 延迟初始化（如 `err`）   | `var err error`                       |
| **局部** | 显式初始化               | `a := 17`（首选短变量声明）           |
| **局部** | 分支控制（if/for）       | `if wv, ok := w.(buffersWriter); ok {` |
| **局部** | 大量变量需要声明         | 使用 `var` 块聚合声明                 |

---

要不要我帮你把这些规则整理成一份 **Go 变量声明速查表**，方便你随时对照检查自己的代码？





