
这段内容是在讲解 Go 语言如何实现**多态**，以及为什么单纯的“组合继承”无法实现真正的方法多态，需要借助**接口（Interface）**来完成。

---

### 8.4 Go 语言实现多态

在面向对象编程中，多态通常分为两种：
- **类的多态**：通过继承实现，子类可以替换父类。
- **方法的多态**：子类重写父类方法，调用时根据对象实际类型执行对应方法。

Go 语言没有传统的继承，所以类的多态需要通过**接口**来实现；而方法的多态，单纯的组合是无法实现的。

---

### 1. 利用方法重写的形式无法实现方法的多态

#### 场景设定
我们定义了一个基础运动员结构体 `DefaultPlayer`，它有两个方法：
- `train()`：默认训练动作
- `sign()`：签到，内部会调用 `train()`

```go
type DefaultPlayer struct {
    name string
}

func (defaultPlayer *DefaultPlayer) train() {
    fmt.Println("默认训练动作")
}

func (defaultPlayer *DefaultPlayer) sign() {
    fmt.Println(defaultPlayer.name, "签到")
    defaultPlayer.train() // 内部调用自己的 train 方法
}
```

然后定义了三个子类结构体（足球、篮球、游泳运动员），它们都**组合**了 `DefaultPlayer`，并重写了 `train()` 方法：

```go
type FootballPlayer struct {
    DefaultPlayer
}

func (footballPlayer *FootballPlayer) train() {
    fmt.Println("足球运动员开始训练")
}

// BasketballPlayer 和 SwimmingPlayer 同理
```

#### 问题出现
当我们创建子类实例并调用 `sign()` 方法时：

```go
func main() {
    footballPlayer := FootballPlayer{DefaultPlayer{"A"}}
    footballPlayer.sign() // 期望调用 FootballPlayer 的 train()
}
```

**实际输出**：
```
A 签到
默认训练动作  // 调用的是 DefaultPlayer 的 train()，而不是子类的
```

**原因分析**：
Go 语言的“继承”本质是**组合**，`DefaultPlayer` 是 `FootballPlayer` 的一个字段，它们之间没有父子指针关系。
- `footballPlayer.sign()` 调用的是嵌入字段 `DefaultPlayer` 的 `sign()` 方法。
- 在 `DefaultPlayer.sign()` 内部，`defaultPlayer.train()` 调用的是 `DefaultPlayer` 自己的 `train()` 方法，它不知道外面还有一个 `FootballPlayer` 重写了这个方法。

这就导致了：**单纯的组合无法实现方法多态**。

---

### 2. Go 语言中实现方法多态的正确方式

要实现真正的多态，就需要打破这种“父类不知道子类”的限制。正确的做法是：
- 将子类实例作为参数，显式地传入父类方法中。
- 或者，使用 Go 语言的核心特性——**接口（Interface）**，通过“面向接口编程”来实现。

例如，我们可以修改 `sign()` 方法，让它接收一个代表所有运动员类型的参数：

```go
func sign(player PlayerType) {
    // ...
    player.train() // 此时会根据 player 的实际类型调用对应的 train() 方法
}
```

这里的 `PlayerType` 就是一个接口，它定义了 `train()` 方法的签名。`FootballPlayer`、`BasketballPlayer` 等只要实现了这个方法，就自动实现了该接口，从而可以被统一处理，实现多态。

---

### 总结

1.  **Go 没有传统继承**：它通过结构体组合来复用代码，但这只是“伪继承”。
2.  **组合无法实现方法多态**：因为父结构体不知道子结构体的存在，内部调用方法时只会调用自己的版本。
3.  **接口是实现多态的关键**：通过定义接口，让不同类型实现相同的方法，就能在运行时根据对象的实际类型调用对应的方法，从而实现真正的多态。

---

要不要我帮你把这个例子用**接口**重写一遍，展示一下 Go 中真正的多态是如何实现的？这样你就能直观地看到区别了。









