

你想彻底搞懂 Go 语言中 `*`（解引用符/指针类型标识）和 `&`（取地址符）的含义、用法和核心区别，我会从基础概念、使用场景到实战示例，用通俗易懂的方式帮你理清——这两个符号是 Go 处理指针的核心，掌握它们就能理解 Go 中“值传递”和“引用传递”的底层逻辑。

### 一、核心概念：指针的本质
在讲解 `*` 和 `&` 之前，先明确**指针**的核心定义：
- 指针是一个**变量**，存储的不是普通值（如 10、"hello"），而是另一个变量在内存中的**地址**；
- 每个变量都有自己的内存地址（可以理解为“房间号”），指针就是记录这个“房间号”的变量；
- `&` 和 `*` 是操作指针的两个核心符号：`&` 拿地址，`*` 用地址取值。

### 二、&（取地址符）：获取变量的内存地址
#### 1. 定义
`&` 读作“取地址”，作用是**获取一个变量在内存中的地址**，返回值是该变量的指针（类型为 `*T`，T 是原变量的类型）。

#### 2. 基础用法
```go
package main

import "fmt"

func main() {
    // 定义普通变量a，值为43，类型int
    a := 43
    fmt.Println("变量a的值：", a)          // 输出：43
    fmt.Println("变量a的地址：", &a)       // 输出：0xc000014078（十六进制地址，随机）
    fmt.Printf("&a的类型：%T\n", &a)      // 输出：*int（指向int的指针类型）

    // 定义指针变量p，存储a的地址
    var p *int = &a
    fmt.Println("指针p的值（a的地址）：", p) // 输出：0xc000014078（和&a一致）
}
```

#### 3. 核心特点
- `&` 只能作用于**可寻址的变量**（如普通变量、数组元素、结构体字段），不能作用于字面量（如 `&10` 编译报错）、常量、临时值；
  ```go
  // 错误示例
  // fmt.Println(&10) // 编译报错：cannot take address of 10 (untyped int constant)
  // const b = 5
  // fmt.Println(&b) // 编译报错：cannot take address of b (untyped int constant)
  ```
- `&变量` 的结果是指针类型（`*T`），可以赋值给同类型的指针变量。

### 三、*（解引用符/指针类型标识）
`*` 有两个核心用途，需根据上下文区分：

#### 用途1：定义指针类型（声明变量时）
在变量声明中，`*T` 表示“指向 T 类型的指针类型”，用于定义指针变量。
```go
// 声明p是一个指向int类型的指针变量，零值为nil（空指针）
var p *int
// 声明q是一个指向string类型的指针变量
var q *string
```

#### 用途2：解引用（使用指针时）
在使用指针时，`*指针变量` 读作“解引用”，作用是**根据指针存储的地址，获取该地址对应的变量值**（即“通过房间号找到房间里的东西”）。

#### 基础用法（结合 &）
```go
package main

import "fmt"

func main() {
    a := 43
    p := &a // p是指针，存储a的地址

    // 1. 解引用：*p 获取指针p指向的变量值（即a的值）
    fmt.Println("*p（解引用）：", *p) // 输出：43（和a的值一致）

    // 2. 修改解引用后的值：会直接修改原变量a的值（核心用途）
    *p = 100 // 把p指向的地址对应的变量值改成100
    fmt.Println("修改后a的值：", a)    // 输出：100（a被修改）
    fmt.Println("修改后*p的值：", *p)  // 输出：100（和a同步）
}
```

#### 核心特点
- 解引用 `*p` 等价于直接操作原变量 `a`，修改 `*p` 就是修改 `a`；
- 对 `nil` 指针（未指向任何地址的指针）解引用会触发 panic：
  ```go
  var p *int // 零值为nil
  // fmt.Println(*p) // panic: runtime error: invalid memory address or nil pointer dereference
  ```

### 四、* 和 & 的核心使用场景
#### 场景1：函数传参（实现“引用传递”）
Go 中函数参数默认是**值传递**（拷贝变量值），如果想让函数修改外部变量，必须传递变量的指针（通过 `&` 传地址，函数内用 `*` 解引用修改）。

```go
package main

import "fmt"

// 错误示例：值传递，修改的是拷贝的副本，外部变量不变
func modifyValue(x int) {
    x = 200
}

// 正确示例：传指针，修改的是原变量
func modifyPointer(x *int) {
    *x = 200 // 解引用，修改原变量值
}

func main() {
    num := 100
    modifyValue(num)
    fmt.Println("值传递后：", num) // 输出：100（未修改）

    modifyPointer(&num) // 传num的地址
    fmt.Println("指针传递后：", num) // 输出：200（已修改）
}
```

#### 场景2：接收用户输入（如 fmt.Scan）
`fmt.Scan` 需要修改外部变量的值，因此必须传入变量的地址（`&变量`）：
```go
package main

import "fmt"

func main() {
    var meters float64
    fmt.Print("输入数字：")
    fmt.Scan(&meters) // 传入meters的地址，Scan才能修改它的值
    fmt.Println("你输入的是：", meters)
}
```

#### 场景3：节省内存（大对象传递）
如果变量是大结构体/大切片，传值会拷贝整个数据（耗内存、慢），传指针仅拷贝地址（8字节/64位系统），效率更高：
```go
package main

import "fmt"

// 大结构体
type BigStruct struct {
    Data [10000]int // 大数组，占内存多
}

// 传指针：仅拷贝地址，效率高
func processBigStruct(bs *BigStruct) {
    bs.Data[0] = 10 // 修改原结构体的值
}

func main() {
    bs := BigStruct{}
    processBigStruct(&bs) // 传地址
    fmt.Println("修改后：", bs.Data[0]) // 输出：10
}
```

### 五、* 和 & 的常见误区
#### 误区1：混淆“指针变量的值”和“解引用后的值”
```go
a := 43
p := &a
// p 是指针变量，值是 a 的地址（如 0xc000014078）
// *p 是解引用，值是 a 的值（43）
fmt.Println("p =", p)   // 输出地址
fmt.Println("*p =", *p) // 输出43
```

#### 误区2：认为 &*p 等价于 p（正确，但无意义）
- `&*p`：先解引用 `*p` 得到变量，再取地址 `&`，结果就是 `p`（地址本身）；
- `*&a`：先取地址 `&a` 得到指针，再解引用 `*`，结果就是 `a`（变量值）；
```go
a := 43
p := &a
fmt.Println(&*p == p) // true
fmt.Println(*&a == a) // true
```

#### 误区3：指针一定比值传递好
- 小变量（如 int、float64）传值比传指针更高效（拷贝8字节比解引用更快）；
- 指针会增加代码复杂度，且可能导致并发安全问题（多个goroutine修改同一地址），需按需使用。

### 六、总结（* 和 & 核心对比）
| 符号 | 名称         | 作用场景                | 核心功能                                  |
|------|--------------|-------------------------|-------------------------------------------|
| `&`  | 取地址符     | 作用于普通变量          | 获取变量的内存地址，返回指针类型（`*T`）   |
| `*`  | 指针类型标识 | 声明变量时              | 定义“指向T类型的指针变量”（如 `var p *int`）|
| `*`  | 解引用符     | 作用于指针变量          | 根据指针地址，获取/修改对应的原变量值      |

### 关键要点回顾
1. `&变量` 拿地址，`*指针` 取/改值，两者是“互逆操作”；
2. 函数中想修改外部变量，必须传 `&变量`（地址），函数内用 `*指针` 解引用修改；
3. 指针的核心价值：实现引用传递、节省大对象拷贝的内存开销；
4. 避免对 nil 指针解引用，会触发 panic。

掌握这两个符号后，你就能理解 Go 中变量的内存布局，以及函数传参的底层逻辑，这是编写高效 Go 代码的基础。












