

你想全面理解 Go 语言中 `range` 关键字的用法，我会从核心定义、遍历不同类型（切片/数组/字符串/map/通道）、关键特性到常见坑点，帮你系统掌握——`range` 是 Go 遍历集合的核心语法，相比普通 `for` 循环更简洁、安全（不会越界）。

### 一、range 核心定义
`range` 只能配合 `for` 循环使用（即 `for-range` 遍历），用于**迭代遍历集合类型**的元素，核心特点：
- 遍历不同类型时，返回值的数量和含义不同（1个或2个）；
- 遍历过程中会生成元素的**副本**（而非原元素本身）；
- 无需手动控制索引/长度，避免数组/切片越界问题；
- 语法：`for [索引/键], [值] := range 集合 { ... }`（可省略索引/键或值）。

### 二、range 遍历不同类型的用法
#### 1. 遍历切片/数组（最常用）
##### 语法与返回值
| 写法                | 返回值1 | 返回值2 | 说明                     |
|---------------------|---------|---------|--------------------------|
| `for i, v := range s` | 索引（int） | 元素值（副本） | 完整遍历（索引+值）|
| `for i := range s`   | 索引（int） | -       | 只遍历索引               |
| `for _, v := range s` | -       | 元素值（副本） | 只遍历值（`_` 占位符）|

##### 示例代码
```go
package main

import "fmt"

func main() {
    nums := []int{10, 20, 30, 40} // 切片
    arr := [2]string{"a", "b"}    // 数组

    // 1. 完整遍历切片（索引+值）
    fmt.Println("遍历切片（索引+值）：")
    for i, v := range nums {
        fmt.Printf("索引：%d，值：%d\n", i, v)
    }
    // 输出：
    // 索引：0，值：10
    // 索引：1，值：20
    // 索引：2，值：30
    // 索引：3，值：40

    // 2. 只遍历数组索引
    fmt.Println("\n遍历数组（只索引）：")
    for i := range arr {
        fmt.Printf("索引：%d，值：%s\n", i, arr[i])
    }
    // 输出：
    // 索引：0，值：a
    // 索引：1，值：b

    // 3. 只遍历切片值
    fmt.Println("\n遍历切片（只值）：")
    for _, v := range nums {
        fmt.Printf("值：%d\n", v)
    }
}
```

##### 核心注意点
- **值是副本**：遍历得到的 `v` 是元素的副本，修改 `v` 不会改变原切片/数组的元素；若要修改原元素，需通过索引操作：
  ```go
  nums := []int{1,2,3}
  // 错误：修改副本，原切片不变
  // for _, v := range nums {
  //     v *= 2
  // }
  // 正确：通过索引修改原元素
  for i := range nums {
      nums[i] *= 2
  }
  fmt.Println(nums) // 输出 [2 4 6]
  ```
- 遍历数组时，`range` 会先将数组转换为切片（拷贝整个数组），因此遍历大数组时建议传指针（`for i, v := range &arr`），避免拷贝开销。

#### 2. 遍历字符串（按 Unicode 字符）
##### 语法与返回值
- 返回值1：字符的**字节索引**（string 底层是字节数组，非 ASCII 字符占多个字节）；
- 返回值2：字符的 **Unicode 码点**（`rune` 类型，可直接转成字符 `%c`）。

##### 示例代码
```go
func main() {
    str := "Go语言" // G(1字节)、o(1字节)、语(3字节)、言(3字节)
    // 完整遍历：字节索引 + Unicode 字符
    for i, c := range str {
        fmt.Printf("字节索引：%d，字符：%c（Unicode码点：%d）\n", i, c, c)
    }
    // 输出：
    // 字节索引：0，字符：G（Unicode码点：71）
    // 字节索引：1，字符：o（Unicode码点：111）
    // 字节索引：2，字符：语（Unicode码点：35821）
    // 字节索引：5，字符：言（Unicode码点：35328）

    // 只遍历字符（忽略字节索引）
    fmt.Println("\n只遍历字符：")
    for _, c := range str {
        fmt.Printf("%c ", c) // 输出：G o 语 言
    }
}
```

##### 核心注意点
- `for-range` 会自动处理 Unicode 字符（包括中文、Emoji 等），按**字符**遍历，而非字节；
- 普通 `for` 循环（`for i:=0; i<len(str); i++`）会按字节遍历，非 ASCII 字符会拆分成多个字节，导致乱码：
  ```go
  str := "语"
  // 普通for按字节遍历（错误）
  for i := 0; i < len(str); i++ {
      fmt.Printf("%c ", str[i]) // 输出乱码：æ ¯
  }
  // for-range按字符遍历（正确）
  for _, c := range str {
      fmt.Printf("%c ", c) // 输出：语
  }
  ```

#### 3. 遍历 map（无序）
##### 语法与返回值
| 写法                | 返回值1 | 返回值2 | 说明                     |
|---------------------|---------|---------|--------------------------|
| `for k, v := range m` | 键（map的key类型） | 值（map的value类型） | 完整遍历（键+值）|
| `for k := range m`   | 键（map的key类型） | -       | 只遍历键                 |
| `for _, v := range m` | -       | 值（map的value类型） | 只遍历值                 |

##### 示例代码
```go
func main() {
    userAge := map[string]int{
        "张三": 20,
        "李四": 25,
        "王五": 30,
    }

    // 1. 完整遍历（键+值）
    fmt.Println("遍历map（键+值）：")
    for k, v := range userAge {
        fmt.Printf("键：%s，值：%d\n", k, v)
    }

    // 2. 只遍历键
    fmt.Println("\n遍历map（只键）：")
    for k := range userAge {
        fmt.Printf("键：%s，值：%d\n", k, userAge[k])
    }

    // 3. 只遍历值
    fmt.Println("\n遍历map（只值）：")
    for _, v := range userAge {
        fmt.Printf("值：%d\n", v)
    }
}
```

##### 核心注意点
- **遍历顺序不固定**：Go 会故意打乱 map 的遍历顺序（每次运行可能不同），不要依赖遍历顺序；
- **遍历中修改map**：
    - 遍历中删除已存在的键：安全；
    - 遍历中新增键：可能导致部分键被重复遍历或跳过；
  ```go
  m := map[int]int{1:1, 2:2}
  // 遍历中删除键（安全）
  for k := range m {
      if k == 1 {
          delete(m, k)
      }
  }
  fmt.Println(m) // 输出 map[2:2]
  ```

#### 4. 遍历通道（channel）
##### 语法与返回值
- 通道遍历只有**一个返回值**（通道中的元素值）；
- 遍历会阻塞，直到通道被关闭（否则会一直等待）；
- 无法遍历 nil 通道（会永久阻塞）。

##### 示例代码
```go
func main() {
    // 带缓冲通道
    ch := make(chan int, 3)
    ch <- 1
    ch <- 2
    ch <- 3
    close(ch) // 必须关闭通道，否则遍历会阻塞

    // 遍历通道（只取元素值）
    fmt.Println("遍历通道：")
    for v := range ch {
        fmt.Printf("值：%d\n", v) // 输出：1、2、3
    }
}
```

##### 核心注意点
- 遍历无缓冲通道：需在另一个 goroutine 中发送数据并关闭通道，否则主线程会阻塞；
- 通道遍历结束的条件：通道关闭且所有元素都被取出。

### 三、range 常见坑点
#### 1. 遍历值是副本（所有类型通用）
遍历得到的“值”是原元素的拷贝，修改副本不会影响原集合：
```go
// 示例：遍历结构体切片
type User struct{ Name string }
users := []User{{"张三"}, {"李四"}}
// 错误：修改副本，原切片不变
for _, u := range users {
    u.Name = "修改后"
}
// 正确：通过索引修改原元素
for i := range users {
    users[i].Name = "修改后"
}
fmt.Println(users) // 输出 [{修改后} {修改后}]
```

#### 2. 循环变量复用问题（Go 1.21 前）
`for-range` 的索引/值变量会被复用（整个循环共用同一个变量），在 goroutine 中引用会导致结果不符合预期：
```go
// 错误示例（Go 1.20及以前）
nums := []int{1,2,3}
for i, v := range nums {
    go func() {
        fmt.Printf("i=%d, v=%d\n", i, v) // 大概率输出 i=2, v=3（三次）
    }()
}
// 正确：将变量作为参数传入goroutine
for i, v := range nums {
    go func(i, v int) {
        fmt.Printf("i=%d, v=%d\n", i, v) // 输出 0,1；1,2；2,3（顺序不固定）
    }(i, v)
}
```
> 注：Go 1.21 引入了 `range` 循环变量语义变更，默认每次迭代创建新变量，解决了该问题，但老版本仍需注意。

#### 3. 遍历 nil 集合
- 遍历 nil 切片/数组：正常执行，循环体不运行（相当于遍历空集合）；
- 遍历 nil map：正常执行，循环体不运行；
- 遍历 nil 通道：永久阻塞（panic 前会卡死）。

### 四、总结
#### range 核心特性
1. 遍历类型适配：
    - 切片/数组：返回「索引+值」，值是副本；
    - 字符串：返回「字节索引+Unicode 字符」，自动处理多字节字符；
    - map：返回「键+值」，遍历顺序不固定；
    - 通道：返回「元素值」，需关闭通道才会结束遍历。
2. 安全性：无需手动控制长度，避免越界；
3. 副本特性：遍历值是原元素的拷贝，修改副本不影响原集合，需通过索引/键修改。

#### 关键要点回顾
1. `for-range` 是 Go 遍历集合的首选方式，简洁且安全；
2. 想修改原集合元素，切片/数组用索引、map 用键，不要直接修改遍历的副本；
3. 遍历字符串优先用 `for-range`（处理 Unicode），遍历 map 不要依赖顺序；
4. 遍历通道必须关闭通道，否则会阻塞。

掌握 `range` 的用法后，你可以高效、安全地遍历 Go 中所有常见的集合类型，避免手动循环的繁琐和越界风险。








