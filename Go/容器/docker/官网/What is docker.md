这份资料详细拆解了 Docker 的核心架构，它不仅是一个工具，更是一套构建、分发和运行应用的标准化系统。既然你关注到了它背后的 **Go 语言** 实现，我们就顺着技术的脉络，把这套架构的“骨架”与“血肉”给彻底理顺。

### 一、 核心架构：经典的 C/S 模型

Docker 最根本的设计模式是**客户端-服务器（Client-Server）**架构。

1.  **Docker 客户端 (Docker Client)**
    *   这是你与 Docker 交互的主要方式。你在命令行输入的 `docker run`、`docker pull` 等指令，都是由客户端发送的。
    *   **工作流**：客户端接收你的命令，通过 **REST API** 把请求发给后台的守护进程。它自己不负责构建镜像或运行容器，只是个“传令兵”。

2.  **Docker 守护进程 (Docker Daemon, dockerd)**
    *   这是后台的“大管家”，负责所有的**重体力活**：构建镜像、运行容器、分发镜像。
    *   **监听与管理**：它监听 Docker API 的请求，并管理 Docker 的核心对象（镜像、容器、网络、数据卷）。它甚至可以与其他守护进程通信，实现集群管理。

3.  **通信方式**
    *   **本地通信**：通常通过 UNIX 套接字（Socket）连接。
    *   **远程通信**：也可以通过网络接口（TCP 端口）连接，这意味着你可以远程管理服务器上的 Docker。

### 二、 三大核心组件：构建、分发与运行

理解 Docker，必须搞清楚它如何完成“构建、分享、运行”的闭环。

#### 1. Docker 镜像 (Images) —— 应用的“只读模板”
*   **定义**：镜像就是构建容器的**源代码**。它是一个只读的模板，包含了运行应用所需的所有文件、代码、运行环境（如 Ubuntu、Nginx）。
*   **分层架构 (Layers)**：这是 Docker 高效的关键。镜像不是一个大文件，而是由一层层的“层”组成。
    *   比如：先有一个 Ubuntu 基础层，上面加一层安装 Java，再加一层放你的代码。
    *   **优势**：当你修改 Dockerfile 并重新构建时，Docker 只重新构建那些被修改的层。这使得镜像非常**轻量、小巧、快速**。
*   **Dockerfile**：这是用来构建镜像的脚本文件，通过简单的语法定义每一步操作。

#### 2. Docker 容器 (Containers) —— 镜像的“运行实例”
*   **定义**：容器是镜像启动后的**运行状态**。它是一个可读写的进程实例。
*   **隔离性**：容器共享宿主机内核，但在自己独立的命名空间（Namespace）里运行。这意味着它看起来像一个独立的虚拟机，但实际上比虚拟机更轻量，因为不需要模拟完整的操作系统内核。
*   **生命周期**：容器由镜像定义，加上你启动时的配置。当容器停止时，默认情况下它不会消失（只是停止运行），你的本地修改如果不持久化存储，重启后就会丢失。

#### 3. Docker 注册表 (Registry) —— 镜像的“仓库”
*   **存储与分享**：镜像构建好后存放在哪里？就在注册表。
*   **Docker Hub**：官方提供的公共注册表，全球开发者都在上面分享镜像，Docker 默认会去这里查找。
*   **私有仓库**：你也可以搭建自己的私有仓库，用于存放机密代码或内部应用。

### 三、 实战拆解：`docker run` 背后发生了什么？

当你执行 `docker run -i -t ubuntu /bin/bash` 时，背后发生了一套精密的流程，这正好印证了它的架构逻辑：

1.  **检查本地**：客户端先去问守护进程，本地有没有 `ubuntu` 这个镜像？
2.  **拉取镜像 (Pull)**：如果本地没有，守护进程会去配置的注册表（默认是 Docker Hub）拉取最新的 `ubuntu` 镜像层到本地。
3.  **创建容器 (Create)**：守护进程根据这个镜像，创建一个新的容器实例。这一步会给容器分配一个**可读写的文件系统层**（这是容器的可写层，用于存储你的临时修改）。
4.  **配置网络**：如果没有指定网络，它会为容器连接到默认的网桥网络，分配一个内部 IP。
5.  **启动容器 (Start)**：容器开始运行。
6.  **执行命令 (Exec)**：最后，在容器内启动 `/bin/bash`，并通过 `-i -t` 参数让你获得交互式终端，你就可以在里面操作 Linux 系统了。

ps:  
Docker 为容器分配一个可读写的文件系统作为其最后一层。这使得正在运行的容器能够在本地文件系统中创建或修改文件和目录。


### 四、 底层技术与 Go 语言实现

你关注的**Go 语言**正是 Docker 的“灵魂”。

1.  **Go 语言的优势**：Docker 完全由 Go 编写。Go 语言编译出的是单一的二进制文件，**不依赖复杂的运行时环境**，这使得 Docker 安装极其简单，且跨平台兼容性极好。同时，Go 的高并发特性完美支撑了 Docker 大量的网络连接和并发请求处理。

2.  **Linux 内核技术 (Namespaces & Control Groups)**
    *   **Namespaces (命名空间)**：这就是 Docker 实现“隔离”的魔法。当你运行一个容器，Docker 会为它创建一组命名空间（PID、网络、挂载、UTS 等）。这意味着容器里的进程看不到宿主机或其他容器的进程，它以为自己就是系统的唯一用户。
    *   **cgroups (控制组)**：这是 Docker 用来**限制资源**的机制。Docker 通过 cgroups 限制容器能使用的 CPU、内存、磁盘 I/O 等资源，防止一个容器耗尽宿主机资源。

### 总结

Docker 本质上就是一个**用 Go 语言编写的、利用 Linux 内核特性（Namespaces/cgroups）构建的高级容器管理系统**。它通过**客户端-服务器架构**解耦了操作与执行，通过**镜像分层技术**实现了高效的分发与存储，最终让应用能够在一个标准化的、可移植的容器环境中平稳运行。这不仅是技术的堆砌，更是对软件工程中“一致性环境”和“微服务架构”的完美技术落地。