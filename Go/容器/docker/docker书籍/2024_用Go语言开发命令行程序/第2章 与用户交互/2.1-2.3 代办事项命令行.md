

这份文档是《用Go语言开发命令行程序》的**第2章核心内容**，聚焦**待办事项CLI工具的完整开发流程**，核心是教你如何**分离业务逻辑与CLI交互层**、实现基础的用户输入输出、处理文件和JSON序列化，同时涵盖Go的包设计、自定义类型、方法、测试等核心知识点。

我会按**核心设计思想、代码实现步骤、关键Go知识点、编译使用**四个维度拆解，把这份偏理论的文档转化为可落地的实操指南，同时解释其中的Go语法和CLI开发最佳实践。

### 一、本章核心设计思想
开发CLI工具的**黄金原则**：<span style="color: #ff6600; font-size: 16px; font-weight: bold;">将业务逻辑封装为独立的可复用包，CLI交互层仅做参数解析、输入输出转发</span>。
- 独立包（`todo`）：实现待办事项的增删改查、持久化（JSON+文件）等核心业务逻辑，对外暴露简洁的API，可被其他程序复用；
- CLI层（`cmd/todo`）：仅处理命令行参数、标准输入输出、错误反馈，调用`todo`包的API完成业务操作，不包含任何业务逻辑。

这种设计的优势：**解耦**（修改CLI交互不影响业务逻辑，复用业务逻辑无需重写CLI）、**易测试**（业务包可单独做单元测试，CLI层做集成测试）。

### 二、完整开发步骤（从目录结构到代码实现）
#### 步骤1：创建标准的项目目录结构
这是Go开发CLI工具的**经典目录结构**，被Docker、Kubernetes等项目广泛使用，必须牢记：
```
todo/                  # 项目根目录（Go模块根目录）
├── cmd/               # 所有CLI入口都放在此目录
│   └── todo/          # 待办事项CLI的专属目录，一个子目录对应一个CLI
│       └── main.go    # CLI入口文件（main包+main函数）
├── todo.go            # todo业务包的核心代码
├── todo_test.go       # todo业务包的单元测试
└── go.mod             # Go模块依赖文件
```
- `cmd/xxx/`：每个CLI工具单独占一个子目录，方便后续扩展多个CLI（如新增`cmd/todo-cli-v2/`）；
- 根目录的`todo.go`：业务包代码，包名`todo`（非main包，编译为库）。

#### 步骤2：初始化Go模块
在项目根目录`todo/`下执行，为项目声明模块路径，方便导入自身的`todo`包：
```bash
go mod init pragprog.com/rggo/interacting/todo
# 模块路径可自定义，只要符合Go模块规范即可（如github.com/你的用户名/todo）
```

#### 步骤3：实现`todo`业务包（核心：自定义类型+方法）
业务包是整个工具的核心，实现**待办事项的数据结构**和**增删改查、持久化方法**，对外仅暴露必要的类型/方法（Go的导出规则）。
##### 3.1 定义两个核心自定义类型
利用Go的**结构体**和**切片**实现，结合**导出规则**控制可见性：
```go
// todo.go - 包名：todo（非main）
package todo

import (
	"encoding/json"
	"errors"
	"fmt"
	"io/ioutil"
	"os"
	"time"
)

// 1. 包私有类型：item（小写开头），代表单个待办事项，外部包不可直接访问
type item struct {
	Task        string    // 待办内容
	Done        bool      // 是否完成
	CreatedAt   time.Time // 创建时间
	CompletedAt time.Time // 完成时间
}

// 2. 导出类型：List（大写开头），代表待办列表，外部包可直接使用
// 基于item切片实现，为其绑定方法实现业务逻辑
type List []item
```
**Go导出规则**：名称**首字母大写**=导出（包外可见），**首字母小写**=包私有（仅包内可见），这是Go控制封装性的核心方式。

##### 3.2 为List类型绑定业务方法
<span style="color: #ff6600; font-size: 15px; font-weight: bold;">方法是**与特定类型关联的函数**</span>，通过**接收器**实现，分为**值接收器**和**指针接收器**，核心规则：
- **指针接收器**：方法需要**修改接收器的内容**时使用（如Add/Delete/Complete），否则修改的是副本，无效；
- **值接收器**：方法仅**读取接收器的内容**时使用；
- 最佳实践：为一个类型的所有方法保持**统一的接收器类型**（如List的所有方法都用指针接收器），提升代码一致性。

实现的核心方法（增删改查+持久化）：

| 方法 | 功能 | 关键细节 |
|------|------|----------|
| `(l *List) Add(task string)` | 添加待办事项 | 初始化item的默认值（Done=false，CreatedAt=当前时间），用`append`追加到切片 |
| `(l *List) Complete(i int) error` | 标记待办完成 | 处理**用户输入的1-based索引**转为Go的0-based切片索引，校验索引合法性 |
| `(l *List) Delete(i int) error` | 删除待办事项 | 切片删除技巧：`append(切片[:n], 切片[n+1:]...)` |
| `(l *List) Save(filename string) error` | 持久化到文件 | 用`json.Marshal`将List转为JSON字节流，`ioutil.WriteFile`写入文件（权限0644） |
| `(l *List) Get(filename string) error` | 从文件加载 | 用`ioutil.ReadFile`读取文件，`json.Unmarshal`解析为List，处理文件不存在/空文件的异常 |

**核心代码片段（关键方法）**：
```go
// Add：添加待办
func (l *List) Add(task string) {
	item := item{
		Task:        task,
		Done:        false,
		CreatedAt:   time.Now(),
		CompletedAt: time.Time{}, // 零值时间
	}
	*l = append(*l, item) // 指针解引用，修改原切片
}

// Complete：标记完成（校验索引）
func (l *List) Complete(i int) error {
	ls := *l
	if i < 1 || i > len(ls) { // 用户输入1-based索引，直接校验
		return fmt.Errorf("item %d does not exist", i)
	}
	ls[i-1].Done = true
	ls[i-1].CompletedAt = time.Now()
	return nil
}

// Save：JSON持久化
func (l *List) Save(filename string) error {
	js, err := json.Marshal(l) // 结构体转JSON
	if err != nil {
		return err
	}
	// 写入文件，权限0644（所有者读写，其他只读）
	return ioutil.WriteFile(filename, js, 0644)
}

// Get：从文件加载，处理文件不存在的异常
func (l *List) Get(filename string) error {
	file, err := ioutil.ReadFile(filename)
	if err != nil {
		if errors.Is(err, os.ErrNotExist) { // 文件不存在，返回nil（首次使用）
			return nil
		}
		return err
	}
	if len(file) == 0 { // 文件为空，返回nil
		return nil
	}
	return json.Unmarshal(file, l) // JSON转结构体
}
```

##### 3.3 为业务包写单元测试（`todo_test.go`）
测试包命名为`todo_test`（原包名+_test），这是Go测试**库包**的最佳实践：
- 测试包与原包分离，仅能访问**导出的类型/方法**（如List），模拟真实的包使用者，保证API的可用性；
- 使用Go内置的`testing`包，测试函数命名规则：`TestXxx(t *testing.T)`；
- 用**临时文件**测试Save/Get方法，避免污染本地文件，测试后自动删除。

**测试核心要点**：
1. 测试Add/Complete/Delete：校验方法的业务逻辑是否正确（如添加后切片长度、标记完成后Done值）；
2. 测试Save/Get：用`ioutil.TempFile`创建临时文件，`defer os.Remove`保证测试后删除，校验序列化/反序列化的一致性；
3. 执行测试命令：`go test -v`（-v显示详细测试日志）。

#### 步骤4：实现CLI交互层（`cmd/todo/main.go`）
CLI层是**用户与业务包的桥梁**，仅做三件事：**解析命令行参数**、**调用业务包API**、**处理输入输出/错误**，无任何业务逻辑。
##### 4.1 核心依赖与常量
```go
// cmd/todo/main.go - 包名：main（必须，编译为可执行文件）
package main

import (
	"fmt"
	"os"
	"strings"
	// 导入自身的todo业务包，路径为Go模块的模块路径
	"pragprog.com/rggo/interacting/todo"
)

// 硬编码持久化的文件名，后续可通过环境变量/flag优化
const todoFileName = ".todo.json"
```

##### 4.2 main函数核心逻辑
CLI的核心流程：**加载本地待办列表** → **根据命令行参数执行对应操作** → **持久化结果**，关键是处理**标准错误（STDERR）**和**退出码**（CLI开发最佳实践）。
```go
func main() {
	// 1. 初始化待办列表（指针类型，绑定方法）
	l := &todo.List{}

	// 2. 从本地文件加载待办列表，处理错误（输出到STDERR，非0退出）
	if err := l.Get(todoFileName); err != nil {
		fmt.Fprintln(os.Stderr, err) // 错误输出到STDERR，而非STDOUT
		os.Exit(1)                   // 非0退出码，标识程序执行失败
	}

	// 3. 根据命令行参数数量，执行不同操作（os.Args是参数切片，第一个元素是程序名）
	switch len(os.Args) {
	// 情况1：无额外参数（仅执行程序）→ 列出所有待办事项
	case 1:
		for _, item := range *l {
			fmt.Println(item.Task) // 正常输出到STDOUT
		}
	// 情况2：有额外参数 → 将参数拼接为待办内容，添加到列表并保存
	default:
		// 拼接所有参数为字符串（os.Args[1:]是排除程序名的所有参数）
		task := strings.Join(os.Args[1:], " ")
		// 调用业务包API添加待办
		l.Add(task)
		// 保存到文件，处理错误
		if err := l.Save(todoFileName); err != nil {
			fmt.Fprintln(os.Stderr, err)
			os.Exit(1)
		}
	}
}
```

##### 4.3 CLI开发的两个最佳实践
文档中重点强调的，也是工业级CLI工具的必备规范：
1. **错误输出到STDERR**：用`fmt.Fprintln(os.Stderr, err)`，而非`fmt.Println`，用户可通过重定向过滤错误（如`./todo 2> error.log`）；
2. **异常退出返回非0码**：用`os.Exit(1)`，而非默认的0，脚本/其他程序可通过退出码判断CLI是否执行成功（如`if ./todo; then echo "成功"; fi`）。

[4.3 补充](#43-补充)



### 三、本章涉及的关键Go知识点（高频考点/实操点）
1. **包与封装**：包的命名规则、导出/包私有类型的控制（首字母大小写）、测试包的命名（原包名+_test）；
2. **自定义类型与方法**：结构体（struct）定义、切片自定义类型、方法的接收器（值/指针）、接收器的最佳实践；
3. **JSON序列化/反序列化**：`encoding/json`包的`Marshal`（结构体→JSON）和`Unmarshal`（JSON→结构体）；
4. **文件操作**：`ioutil`包（Go1.16后迁移到`os`/`io`包）的`ReadFile`/`WriteFile`、临时文件`TempFile`；
5. **命令行参数**：`os.Args`切片（存储命令行参数）、第一个元素为程序名；
6. **标准输入输出**：`os.Stdout`（标准输出）、`os.Stderr`（标准错误）、`fmt.Fprintln`向指定流输出；
7. **测试**：内置`testing`包、测试函数命名规则、`TestMain`（测试前置/后置操作）、临时资源的清理（`defer`）。

### 四、编译与使用这个待办事项CLI工具
#### 步骤1：编译CLI可执行文件
在**项目根目录**执行，指定输出路径为`todo`（可自定义），编译`cmd/todo/main.go`：
```bash
# 编译命令：go build -o 输出文件名 入口文件路径
go build -o todo cmd/todo/main.go
```
执行后，项目根目录会生成一个名为`todo`的可执行文件（Windows下为`todo.exe`）。

#### 步骤2：赋予执行权限（Linux/macOS）
```bash
chmod +x todo
```

#### 步骤3：使用CLI工具
```bash
# 1. 无参数 → 列出所有待办事项（首次使用为空，无输出）
./todo

# 2. 带参数 → 添加待办事项（参数为待办内容，支持空格）
./todo 学习Go语言 CLI开发
./todo 整理待办事项文档

# 3. 再次无参数 → 列出已添加的待办
./todo
# 输出：
# 学习Go语言 CLI开发
# 整理待办事项文档
```
**持久化原理**：执行添加操作后，本地会生成`.todo.json`文件，存储JSON格式的待办列表，下次执行会自动加载。

### 五、后续扩展方向（文档铺垫的优化点）
本章实现的是**基础版本**，后续可通过Go的其他特性优化，文档中也做了铺垫：
1. **添加flag参数**：用`flag`包实现`-complete`/`-delete`参数，支持标记完成/删除待办（如`./todo -complete 1`）；
2. **环境变量配置**：用`os.Getenv`读取环境变量，替换硬编码的`todoFileName`（如`TODO_FILE=my-todo.json ./todo`）；
3. **支持标准输入**：通过`io.Reader`读取STDIN，支持管道输入（如`echo "新待办" | ./todo`）；
4. **替换废弃的ioutil**：Go1.16后`ioutil`被废弃，替换为`os.ReadFile`/`os.WriteFile`/`io.TempFile`；
5. **添加颜色输出**：用第三方包（如`github.com/fatih/color`）实现STDOUT的彩色输出，提升用户体验；
6. **子命令**：用`flag.FlagSet`或第三方框架（Cobra）实现子命令（如`./todo add`/`./todo list`/`./todo delete`）。

### 总结
本章的核心不是实现一个简单的待办事项工具，而是**教会你Go开发CLI工具的标准范式**：
1. 目录结构：`cmd/xxx/`存放CLI入口，根目录存放业务包；
2. 代码解耦：业务逻辑封装为独立库包，CLI层仅做交互；
3. 封装性：用Go的导出规则控制包的对外API；
4. 工程化：为业务包写单元测试，遵循CLI开发的最佳实践（STDERR输出错误、非0退出码）。

这个范式是Go生态中所有工业级CLI工具的基础，掌握后可以开发任何自定义的CLI工具（如Docker、Kubectl的简易版）。








## 4.3 补充

[4.3 CLI开发的两个最佳实践](#43-CLI开发的两个最佳实践)

你想理解的是工业级 CLI 工具开发中两个核心的最佳实践——错误输出到 STDERR 和异常退出返回非 0 码，这两个规范是保证 CLI 工具易用、可集成的关键，我会用通俗的语言+代码示例帮你彻底搞懂。

### 一、第一个实践：错误输出到 STDERR（标准错误流）
#### 1. 核心概念
在操作系统中，程序运行时有两个最基础的输出通道：
- **STDOUT（标准输出）**：专门用来输出程序的**正常结果**（比如 CLI 执行成功后的返回数据、提示信息）。
- **STDERR（标准错误）**：专门用来输出程序的**错误信息**（比如参数错误、文件不存在、执行失败等）。

默认情况下，这两个通道都会把内容打印到终端，肉眼看起来没区别，但背后的设计目的和使用场景完全不同。

#### 2. 为什么要这么做？
如果把错误信息混在 STDOUT 里，会导致：
- 用户无法通过重定向单独收集错误日志（比如只想保存错误，过滤正常输出）。
- 脚本/其他程序无法区分“正常结果”和“错误信息”，集成时容易出错。

#### 3. 代码示例（对比）
❌ 错误写法（混输）：
```go
package main

import (
	"fmt"
	"os"
)

func main() {
	// 模拟读取文件失败
	file, err := os.Open("nonexist.txt")
	if err != nil {
		// 错误信息输出到 STDOUT
		fmt.Println("读取文件失败：", err) 
		return
	}
	defer file.Close()

	// 正常结果输出到 STDOUT
	fmt.Println("文件读取成功")
}
```

✅ 正确写法（错误输出到 STDERR）：
```go
package main

import (
	"fmt"
	"os"
)

func main() {
	file, err := os.Open("nonexist.txt")
	if err != nil {
		// 错误信息输出到 STDERR
		fmt.Fprintln(os.Stderr, "读取文件失败：", err) 
		return
	}
	defer file.Close()

	// 正常结果输出到 STDOUT
	fmt.Println("文件读取成功")
}
```

#### 4. 实际使用价值
用户可以通过重定向分别处理正常输出和错误：
```bash
# 正常输出保存到 output.log，错误输出保存到 error.log
./your-cli > output.log 2> error.log

# 只看正常输出，忽略错误
./your-cli 2> /dev/null

# 只看错误输出，忽略正常输出
./your-cli > /dev/null
```

### 二、第二个实践：异常退出返回非 0 码
#### 1. 核心概念
程序运行结束后，会向操作系统返回一个**退出码（Exit Code）**：
- **0**：表示程序**执行成功**（无异常）。
- **非 0**（通常用 1，也可自定义 2、3 等）：表示程序**执行失败**（不同数字可区分不同错误类型）。

操作系统/脚本会根据这个退出码判断程序是否正常完成，这是自动化脚本集成 CLI 的核心依据。

#### 2. 为什么要这么做？
如果异常时仍返回 0，会导致：
- 脚本误以为程序执行成功，继续执行后续逻辑（比如“删除文件失败”后，脚本仍执行“备份新文件”，导致数据错误）。
- 无法通过脚本判断 CLI 执行状态（比如 CI/CD 流水线无法感知 CLI 失败，导致流水线误判为成功）。

#### 3. 代码示例（对比）
❌ 错误写法（异常仍返回 0）：
```go
package main

import (
	"fmt"
	"os"
)

func main() {
	file, err := os.Open("nonexist.txt")
	if err != nil {
		fmt.Fprintln(os.Stderr, "读取文件失败：", err)
		// 没有主动退出，程序正常结束，返回 0
		return
	}
	defer file.Close()

	fmt.Println("文件读取成功")
}
```

✅ 正确写法（异常返回非 0 码）：
```go
package main

import (
	"fmt"
	"os"
)

func main() {
	file, err := os.Open("nonexist.txt")
	if err != nil {
		fmt.Fprintln(os.Stderr, "读取文件失败：", err)
		// 异常退出，返回 1
		os.Exit(1) 
	}
	defer file.Close()

	fmt.Println("文件读取成功")
	// 正常退出，默认返回 0（无需手动调用 os.Exit(0)）
}
```

#### 4. 实际使用价值
脚本可以通过退出码判断逻辑：
```bash
# 脚本中判断 CLI 是否执行成功
if ./your-cli; then
    echo "CLI 执行成功，继续后续操作"
else
    echo "CLI 执行失败，退出脚本"
    exit 1
fi

# 直接查看上一个程序的退出码（Linux/macOS）
echo $? 
# 执行成功输出 0，失败输出 1
```

### 完整示例（两个实践结合）
```go
package main

import (
	"fmt"
	"os"
)

func main() {
	// 检查参数是否正确
	if len(os.Args) < 2 {
		fmt.Fprintln(os.Stderr, "错误：缺少参数，请指定要读取的文件路径")
		os.Exit(1) // 参数错误，返回 1
	}

	filePath := os.Args[1]
	file, err := os.Open(filePath)
	if err != nil {
		fmt.Fprintln(os.Stderr, "错误：读取文件失败 -", err)
		os.Exit(2) // 文件读取错误，返回 2（区分不同错误类型）
	}
	defer file.Close()

	fmt.Printf("成功读取文件：%s\n", filePath)
	// 正常退出，默认返回 0
}
```

### 总结
1. **错误输出到 STDERR**：核心是分离“正常结果”和“错误信息”，让用户/脚本能灵活过滤、收集不同类型的输出，使用 `fmt.Fprintln(os.Stderr, err)` 实现。
2. **异常退出返回非 0 码**：核心是给操作系统/脚本提供明确的执行状态标识，使用 `os.Exit(非0值)` 实现，0 表示成功，非 0 表示失败（可自定义数字区分错误类型）。

这两个实践是 CLI 工具从“能用”到“工业级可用”的关键，也是 Linux/UNIX 生态下的通用规范，几乎所有成熟的 CLI 工具（如 ls、git、docker）都遵循这一规则。


