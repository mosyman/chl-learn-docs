
这几页内容主要讲了两个 Go 语言实战知识点：**用 `flag` 包扩展命令行功能**和**交叉编译实现跨平台分发**，我帮你拆解一下：

---

### 1.3 添加命令行标志（Command-Line Flags）
这一节是在之前单词计数器的基础上，通过命令行标志 `-l` 来扩展功能：
- 默认行为：统计单词数（`words`）
- 启用 `-l` 标志：统计行数（`lines`）

#### 核心步骤：
1.  **导入 `flag` 包**
    ```go
    import "flag"
    ```
2.  **定义并解析标志**
    ```go
    func main() {
        // 定义一个布尔型 flag -l，默认值 false，描述为 "Count lines"
        lines := flag.Bool("l", false, "Count lines")
        // 解析命令行传入的所有 flag
        flag.Parse()

        // 调用 count 函数，传入标志值决定统计方式
        fmt.Println(count(os.Stdin, *lines))
    }
    ```
3.  **修改 `count` 函数**
    根据 `countLines` 参数，动态设置 `bufio.Scanner` 的分割方式：
    ```go
    func count(r io.Reader, countLines bool) int {
        scanner := bufio.NewScanner(r)

        // 如果 countLines 为 true，则按行分割；否则按单词分割
        if !countLines {
            scanner.Split(bufio.ScanWords)
        }

        wc := 0
        for scanner.Scan() {
            wc++
        }
        return wc
    }
    ```
4.  **测试验证**
    - 新增 `TestCountLines` 测试函数，验证行数统计逻辑。
    - 运行 `go test -v`，确保单词统计和行数统计两种模式都正常。
5.  **使用示例**
    ```bash
    # 统计 main.go 的行数
    cat main.go | ./wc -l
    # 输出：43
    ```

---

### 1.4 编译成跨平台工具
这一节讲解 Go 的**交叉编译**能力，让同一个工具可以在不同操作系统和架构上运行，无需额外依赖。

#### 核心步骤：
1.  **设置目标平台环境变量**
    通过 `GOOS`（目标操作系统）和 `GOARCH`（目标架构）来指定编译目标：
    ```bash
    # 编译为 Windows 64位可执行文件
    GOOS=windows go build
    ```
    其他常见组合：
    ```bash
    # Linux 64位
    GOOS=linux GOARCH=amd64 go build
    # macOS 64位
    GOOS=darwin GOARCH=amd64 go build
    # macOS ARM64 (Apple Silicon)
    GOOS=darwin GOARCH=arm64 go build
    ```
2.  **验证编译结果**
    ```bash
    # 查看生成的 Windows 可执行文件信息
    file wc.exe
    # wc.exe: PE32+ executable (console) x86-64 ... for MS Windows
    ```
3.  **跨平台运行**
    生成的二进制文件是**静态链接**的，不依赖任何运行时环境，可以直接在目标平台运行。

---

### 总结
- **命令行标志**：通过 `flag` 包可以轻松为工具添加灵活的配置选项，扩展功能。
- **交叉编译**：Go 强大的编译工具链让你可以一键构建出支持 Windows、Linux、macOS 等多平台的可执行文件，极大简化了分发流程。

---

要不要我帮你把这两节的代码整合起来，生成一个完整的 `wc` 工具，你可以直接在本地运行和测试？










