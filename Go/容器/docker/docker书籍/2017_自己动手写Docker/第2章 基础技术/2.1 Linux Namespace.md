

# Linux Namespace 详细解释（Docker 核心基础技术）
Linux Namespace 是Linux内核提供的**资源隔离核心功能**，也是Docker实现容器进程隔离的底层技术之一。它能为进程创建独立的系统资源视图，让不同Namespace中的进程仿佛运行在独立的Linux系统中，彼此无法感知、互不干扰；同时父Namespace可管理子Namespace，兼顾隔离性和可管控性。

简单来说，Namespace的隔离效果类似轻量级虚拟化，但无需模拟硬件，仅通过内核做资源视图隔离，性能损耗极低，这也是Docker比传统虚拟机更轻量的关键原因。

## 一、Linux Namespace 核心概念
1. **隔离本质**：为进程隔离特定系统资源，如PID、用户ID、网络、挂载点等，每个Namespace拥有独立的资源实例。
2. **与chroot的区别**：chroot仅能隔离文件系统的根目录，而Namespace是**多维度的资源隔离**，覆盖进程、网络、用户等多个层面，且隔离更彻底、更灵活。
3. **父子Namespace关系**：子Namespace由父Namespace创建，父Namespace可感知所有子Namespace的运行状态，子Namespace之间完全隔离；子Namespace内的资源会被**映射**到父Namespace中（如子Namespace的PID 1，在父Namespace中是普通PID）。
4. **核心价值**：解决了“多用户/多应用共享物理机”的隔离问题，比如让非root用户在自己的Namespace内拥有root权限，既满足应用的系统权限需求，又不会影响宿主机和其他Namespace。

## 二、Linux 已实现的6种Namespace类型
当前Linux内核共实现6种Namespace，分别对应不同的隔离资源，各有专属的系统调用参数和内核支持版本，也是Docker实现容器隔离的核心维度，具体如下表：

| Namespace类型 | 系统调用参数 | 内核版本 | 核心隔离能力 | 核心应用场景 |
|--------------|--------------|----------|--------------|--------------|
| Mount Namespace | CLONE_NEWNS | 2.4.19 | 隔离进程看到的文件系统挂载点视图，mount/umount操作仅对当前Namespace生效 | Docker镜像挂载、Volume数据卷、容器独立文件系统 |
| UTS Namespace | CLONE_NEWUTS | 2.6.19 | 隔离`nodename`和`domainname`，即每个Namespace有独立的主机名（hostname） | 让每个Docker容器拥有自己的主机名，与宿主机和其他容器区分 |
| IPC Namespace | CLONE_NEWIPC | 2.6.19 | 隔离System V IPC和POSIX消息队列 | 防止容器间的进程间通信相互干扰，保证IPC资源私有 |
| PID Namespace | CLONE_NEWPID | 2.6.24 | 隔离进程ID，同一进程在不同Namespace有不同PID，子Namespace的首个进程为PID 1（init进程） | Docker容器内的进程以PID 1运行，与宿主机PID完全隔离，容器内`ps -ef`仅看到自身进程 |
| Network Namespace | CLONE_NEWNET | 2.6.29 | 隔离网络设备、IP地址、端口、路由等网络资源 | 让每个Docker容器拥有独立的网络栈，端口可重复使用，容器间网络可通过网桥互通 |
| User Namespace | CLONE_NEWUSER | 3.8 | 隔离用户/用户组ID，Namespace内外的UID/GID可映射（非root用户可在内部映射为root） | 提升Docker安全性，宿主机普通用户运行的容器，内部可拥有root权限，且不会影响宿主机 |

### 关键说明
- 6种Namespace可**组合使用**（通过系统调用参数的按位或`|`实现），Docker容器正是同时创建了这6种Namespace，实现了全方位的资源隔离；
- 内核版本是基础要求，Docker运行的宿主机内核需不低于各Namespace的最低支持版本（实际Docker要求内核3.10+，满足所有Namespace需求）。

## 三、Linux Namespace 核心API（系统调用）
内核为Namespace提供了3个核心系统调用，所有基于Namespace的隔离操作（如Docker创建容器）均通过这3个调用实现，Go/C等语言会对其做封装，简化开发：
1. **clone()**：**创建新进程并同时创建Namespace**，通过传入不同的CLONE_*参数（如CLONE_NEWUTS、CLONE_NEWPID），指定要创建的Namespace类型，新进程及其子进程会被包含在这些Namespace中；
2. **unshare()**：将**当前进程移出某个已存在的Namespace**，让进程脱离原有隔离环境，进入独立的资源视图；
3. **setns()**：将**当前进程加入到一个已存在的Namespace**，实现进程对已有隔离环境的访问（如Docker exec进入容器，就是通过该调用将终端进程加入容器的Namespace）。

## 四、6种Namespace 详细功能与实现示例
所有示例均基于Go语言（与Docker开发语言一致），核心是通过`syscall.SysProcAttr.Cloneflags`设置Namespace的系统调用参数，创建隔离的sh进程环境，验证隔离效果。

### 1. UTS Namespace（主机名隔离）
#### 核心功能
让每个Namespace拥有独立的主机名，修改内部主机名不会影响宿主机和其他Namespace。
#### 核心代码
```go
package main
import (
    "os/exec"
    "syscall"
    "os"
    "log"
)
func main() {
    cmd := exec.Command("sh")
    // 设置创建UTS Namespace
    cmd.SysProcAttr = &syscall.SysProcAttr{Cloneflags: syscall.CLONE_NEWUTS}
    cmd.Stdin, cmd.Stdout, cmd.Stderr = os.Stdin, os.Stdout, os.Stderr
    if err := cmd.Run(); err != nil {
        log.Fatal(err)
    }
}
```
#### 验证效果
- 运行代码进入隔离的sh环境，执行`hostname -b bird`修改主机名为bird，内部执行`hostname`会输出`bird`；
- 宿主机新打开shell执行`hostname`，仍显示宿主机原有主机名，说明隔离生效；
- 通过`readlink /proc/[父进程PID]/ns/uts`和`readlink /proc/[子进程PID]/ns/uts`可查看，父子进程的UTS Namespace标识不同。

### 2. IPC Namespace（进程间通信隔离）
#### 核心功能
隔离System V IPC和POSIX消息队列，每个Namespace拥有独立的IPC资源，内部无法看到宿主机或其他Namespace的IPC队列。
#### 核心代码
在UTS Namespace基础上，**按位或**添加CLONE_NEWIPC参数，实现UTS+IPC双重隔离：
```go
cmd.SysProcAttr = &syscall.SysProcAttr{
    Cloneflags: syscall.CLONE_NEWUTS | syscall.CLONE_NEWIPC,
}
```
#### 验证效果
- 宿主机执行`ipcmk -Q`创建消息队列，通过`ipcs -q`可查看到该队列；
- 运行代码进入隔离环境，执行`ipcs -q`，**无法看到**宿主机创建的消息队列，说明IPC资源隔离生效。

### 3. PID Namespace（进程ID隔离）
#### 核心功能
隔离进程ID，子Namespace的首个进程会被分配PID 1（模拟Linux的init进程），容器内的进程PID从1开始递增，与宿主机PID完全独立。
#### 核心代码
在UTS+IPC基础上，添加CLONE_NEWPID参数：
```go
cmd.SysProcAttr = &syscall.SysProcAttr{
    Cloneflags: syscall.CLONE_NEWUTS | syscall.CLONE_NEWIPC | syscall.CLONE_NEWPID,
}
```
#### 验证效果
- 宿主机通过`pstree -pl`可看到隔离进程的**真实PID**（如20193）；
- 隔离环境内执行`echo $$`，输出**1**，说明进程在子Namespace中被映射为PID 1；
- 此时暂无法使用`ps`命令（依赖/proc文件系统，需结合Mount Namespace）。

### 4. Mount Namespace（文件系统挂载隔离）
#### 核心功能
隔离进程的文件系统挂载点视图，mount/umount操作仅对当前Namespace生效；可将独立的/proc文件系统挂载到内部，让`ps/top`等命令仅显示Namespace内的进程。
#### 关键特性
是Linux第一个实现的Namespace，也是实现容器独立文件系统的基础，Docker的镜像层、数据卷均基于此实现。
#### 核心代码
在UTS+IPC+PID基础上，添加CLONE_NEWNS参数：
```go
cmd.SysProcAttr = &syscall.SysProcAttr{
    Cloneflags: syscall.CLONE_NEWUTS | syscall.CLONE_NEWIPC | syscall.CLONE_NEWPID | syscall.CLONE_NEWNS,
}
```
#### 验证效果
- 运行代码进入隔离环境，初始`ls /proc`仍看到宿主机的proc内容，执行`mount -t proc proc /proc`将proc文件系统挂载到内部；
- 再次执行`ls /proc`，仅显示Namespace内的进程文件，执行`ps -ef`，仅能看到`sh`（PID 1）和`ps`（PID 6），说明文件系统挂载和进程视图均隔离生效。

### 5. User Namespace（用户/用户组隔离）
#### 核心功能
隔离UID/GID，实现**内外ID映射**：宿主机的非root用户，可在子Namespace内被映射为root（UID 0），拥有内部的root权限，但在宿主机上仍为普通用户，大幅提升安全性。
#### 关键特性
Linux 3.8+支持非root进程创建User Namespace，是Docker“非root运行”的核心技术基础。
#### 核心代码
在前4种Namespace基础上，添加CLONE_NEWUSER，并通过`Credential`设置宿主机映射的UID/GID：
```go
cmd.SysProcAttr = &syscall.SysProcAttr{
    Cloneflags: syscall.CLONE_NEWUTS | syscall.CLONE_NEWIPC | syscall.CLONE_NEWPID | syscall.CLONE_NEWNS | syscall.CLONE_NEWUSER,
    Credential: &syscall.Credential{Uid: uint32(1), Gid: uint32(1)}, // 宿主机UID/GID 1
}
```
#### 验证效果
- 宿主机以root（UID 0）运行代码，执行`id`显示`uid=0(root) gid=0(root)`；
- 隔离环境内执行`id`，输出`uid=65534(nobody) gid=65534(nogroup)`，说明UID/GID映射生效，User Namespace隔离成功。

### 6. Network Namespace（网络资源隔离）
#### 核心功能
隔离所有网络资源，包括网络设备、IP地址、端口、路由表、防火墙规则等；子Namespace默认无任何网络设备（包括lo回环），需手动创建虚拟网络设备（如veth pair）并连接到网桥，才能实现与宿主机/其他容器的通信。
#### 核心价值
让每个Docker容器拥有**独立的网络栈**，容器内的端口（如8080）可重复使用，无需担心端口冲突。
#### 核心代码
在5种Namespace基础上，添加CLONE_NEWNET参数，实现全维度隔离：
```go
cmd.SysProcAttr = &syscall.SysProcAttr{
    Cloneflags: syscall.CLONE_NEWUTS | syscall.CLONE_NEWIPC | syscall.CLONE_NEWPID | syscall.CLONE_NEWNS | syscall.CLONE_NEWUSER | syscall.CLONE_NEWNET,
    Credential: &syscall.Credential{Uid: uint32(1), Gid: uint32(1)},
}
```
#### 验证效果
- 宿主机执行`ifconfig`，可看到eth0、eth1、lo、docker0等网络设备；
- 隔离环境内执行`ifconfig`，**无任何输出**，说明子Namespace内无网络设备，网络资源完全隔离。

## 五、Linux Namespace 与 Docker 的关系
Docker容器的**隔离性核心**由Linux Namespace实现，Docker创建容器的过程，本质上是通过`clone()`系统调用，为容器进程同时创建上述6种Namespace，再结合Linux Cgroups（资源限制），实现“隔离+限制”的容器特性：
1. **Namespace实现隔离**：让容器成为独立的“轻量级虚拟机”，拥有自己的主机名、PID、网络、文件系统、用户权限；
2. **Cgroups实现资源限制**：限制容器的CPU、内存、磁盘IO、网络带宽等资源，防止单个容器占用宿主机全部资源。

简单来说：**Namespace让容器“看不见”其他容器的资源，Cgroups让容器“用不完”宿主机的资源**，两者结合构成了Docker容器的底层基础。

## 六、Linux Namespace 的特点
1. **轻量级**：仅通过内核做资源视图隔离，无需模拟硬件，性能损耗远低于传统虚拟机；
2. **细粒度**：6种Namespace可按需组合，支持单维度/多维度隔离，灵活性高；
3. **层级化**：父子Namespace的层级管理，让宿主机（根Namespace）可统一管理所有容器（子Namespace）；
4. **原生内核支持**：无需额外安装软件，仅需内核开启相关功能，兼容性好；
5. **非完全隔离**：Namespace是**内核级的资源隔离**，并非硬件级隔离，若内核存在漏洞，可能出现隔离逃逸，因此需配合安全加固（如Seccomp、AppArmor）。

我可以帮你整理**Linux Namespace 核心代码片段**（6种类型的完整可运行Go代码），并标注关键参数和验证步骤，需要吗？


