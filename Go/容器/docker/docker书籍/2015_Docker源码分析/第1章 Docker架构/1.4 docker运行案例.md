

这几页内容详细拆解了 Docker 1.2.0 版本中两个核心命令 `docker pull` 和 `docker run` 的执行流程，我帮你把整个过程梳理清楚：

---

## 一、`docker pull` 命令执行流程

`docker pull` 的作用是从 Docker Registry 下载镜像并存储到本地 Graph 中，供后续创建容器使用。

### 执行步骤：
1.  **客户端发起请求**
    Docker Client 解析用户输入的 `docker pull` 命令，向 Docker Server 发送一个 POST 请求，URL 为 `/images/create?xxx`，表示要下载指定镜像。

2.  **路由分发**
    Docker Server 接收请求后，交给 `gorilla/mux` 路由库，`mux.Router` 根据 URL 和请求方法，将请求路由到对应的 handler：`PostImagesCreate`。

3.  **创建并执行 Job**
    在 <span style="color: #ff6600; font-size: 16px; font-weight: bold;">`PostImagesCreate` handler</span> 中，创建并初始化一个名为 `pull` 的 Job，然后触发执行。

4.  **下载镜像**
    `pull` Job 执行 `pullRepository` 操作，从 Docker Registry 下载指定的一个或多个镜像。

5.  **存储镜像**
    `pull` Job 将下载好的镜像交给 `graphdriver` 管理。`graphdriver` 负责将镜像存储到本地文件系统，并为镜像创建对象，供 Docker Daemon 统一管理。

---

## 二、`docker run` 命令执行流程

`docker run` 是 Docker 中最核心的命令，它的执行分为两个阶段：**创建容器**和**启动容器**，因此 Docker Client 会向 Docker Server 发送两次 HTTP 请求。

### 第一阶段：创建容器（第一次 HTTP 请求）

1.  **客户端发起创建请求**
    Docker Client 解析 `docker run` 命令，向 Docker Server 发送 POST 请求，URL 为 `/containers/create?xxx`，请求创建一个容器对象（此时容器并未运行）。

2.  **路由分发**
    请求被 `mux.Router` 路由到 `PostContainersCreate` handler。

3.  **创建 "create" Job**
    handler 中创建并执行名为 `create` 的 Job。

4.  **准备容器 rootfs**
    `create` Job 执行 `Container.Create` 操作，通过 `graphdriver` 从 Graph 中获取镜像，将所有镜像层通过联合文件系统（如 aufs）加载，为容器准备好 rootfs（文件系统根目录）。

### 第二阶段：启动容器（第二次 HTTP 请求）

如果容器创建成功，Docker Client 会自动发起第二次请求：

5.  **客户端发起启动请求**
    发送 POST 请求到 URL `/containers/{container_id}/start`，请求启动刚才创建的容器。

6.  **路由分发**
    请求被 `mux.Router` 路由到 `PostContainersStart` handler。

7.  **创建 "start" Job**
    handler 中创建并执行名为 `start` 的 Job。

8.  **配置网络环境**
    `start` Job 调用 `networkdriver`，为容器分配网络资源，如 IP 地址、端口，并设置防火墙规则。

9.  **初始化运行环境**
    `start` Job 调用 `execdriver`，`execdriver` 再调用 `libcontainer`，完成容器运行环境的初始化：
    -   创建隔离的命名空间（namespace）
    -   设置资源限制（cgroups）
    -   最终执行用户指定的命令，容器开始运行。

---

## 三、核心总结

- **模块化协作**：无论是 `pull` 还是 `run`，整个流程都是 Docker 架构中各个模块（Client、Server、Engine、Job、Driver、libcontainer）紧密协作的结果。
- **Job 模型**：Docker Daemon 内部的所有任务都被抽象成 `Job`，如 `pull`、`create`、`start`，这种设计让任务管理和执行更加清晰。
- **驱动隔离**：存储（graphdriver）、网络（networkdriver）、执行（execdriver）都通过驱动层实现，使得 Docker 可以灵活适配不同的底层技术。

---

要不要我帮你把这两个流程整理成一张**对比表**，让你一眼看清 `pull` 和 `run` 的区别和联系？











